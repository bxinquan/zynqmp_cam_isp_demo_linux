// SPDX-License-Identifier: GPL-2.0
/*
 * A V4L2 driver for Aptina AR1335 cameras.
 *
 * Based on Samsung S5K6AAFX SXGA 1/6" 1.3M CMOS Image Sensor driver
 * Copyright (C) 2011 Sylwester Nawrocki <s.nawrocki@samsung.com>
 *
 * Based on Omnivision OV7670 Camera Driver
 * Copyright (C) 2006-7 Jonathan Corbet <corbet@lwn.net>
 *
 * Copyright (C) 2016, Synopsys, Inc.
 */

#include <linux/clk.h>
#include <linux/delay.h>
#include <linux/gpio/consumer.h>
#include <linux/i2c.h>
#include <linux/init.h>
#include <linux/io.h>
#include <linux/module.h>
#include <linux/of_graph.h>
#include <linux/pm_runtime.h>
#include <linux/slab.h>
#include <linux/videodev2.h>
#include <media/v4l2-ctrls.h>
#include <media/v4l2-device.h>
#include <media/v4l2-event.h>
#include <media/v4l2-fwnode.h>
#include <media/v4l2-image-sizes.h>
#include <media/v4l2-mediabus.h>

/*
 * From the datasheet, "20ms after PWDN goes low or 20ms after RESETB goes
 * high if reset is inserted after PWDN goes high, host can access sensor's
 * SCCB to initialize sensor."
 */
#define PWDN_ACTIVE_DELAY_MS	20

#define AR1335_REG_CHIPID_H			0x0000
#define AR1335_REG_CHIPID_L			0x0001
#define AR1335_REG_SW_RESET			0x0103

#define AR1335_REG_EXPOSURE			0x0202
#define AR1335_REG_GAIN				0x305E
#define AR1335_REG_VTS				0x0340

#define AR1335_VBLANK_MIN		142
#define AR1335_VTS_MAX			65535

#define AR1335_EXPOSURE_MIN		8
#define AR1335_EXPOSURE_STEP		1
#define AR1335_EXPOSURE_DEFAULT		1000

struct regval_list {
	u16 addr;
	u16 data;
};
#define REG_DELAY  0xffff

struct ar1335_mode {
	struct v4l2_mbus_framefmt	format;
	u64				pixel_rate;
	int				hts;
	int				vts;
	const struct regval_list	*reg_list;
	unsigned int			num_regs;
};

struct ar1335 {
	struct v4l2_subdev		sd;
	struct media_pad		pad;
	struct mutex			lock;
	struct clk			*xclk;
	struct gpio_desc		*pwdn;
	struct v4l2_ctrl_handler	ctrls;
	const struct ar1335_mode	*mode;
	struct v4l2_ctrl		*pixel_rate;
	struct v4l2_ctrl		*hblank;
	struct v4l2_ctrl		*vblank;
	struct v4l2_ctrl		*exposure;
	bool				streaming;
};

static inline struct ar1335 *to_sensor(struct v4l2_subdev *sd)
{
	return container_of(sd, struct ar1335, sd);
}

static const struct regval_list ar1335_3840x2160_20fps_raw10_48Mxclk[] = {
	//[static struct vvsensor_ar1335_reg_value_t ar1335_init_setting_4kp_48Mxclk]
	{0x301A, 0x0219},// RESET_REGISTER
	{REG_DELAY, 10},
	{0x3042, 0x1004},// DARK_CONTROL2
	{0x30D2, 0x0120},// CRM_CONTROL
	{0x30D4, 0x0000},// COLUMN_CORRECTION
	{0x3090, 0x0000},// RNF_CONTROL
	{0x30FC, 0x0060},// MODULE_CLK_OFF
	{0x30FE, 0x0060},// CTREE_OFF
	{0x31E0, 0x0781},// PIX_DEF_ID
	{0x3180, 0x9434},// FINE_DIG_CORRECTION_CONTROL
	{0x317C, 0xEFF4},// ANALOG_CONTROL7
	{0x30EE, 0x613E},// DARK_CONTROL3
	{0x3F2C, 0x4428},// GTH_THRES_RTN
	{0x3D00, 0x0446},// DYNAMIC_SEQRAM_00
	{0x3D02, 0x4C66},// DYNAMIC_SEQRAM_02
	{0x3D04, 0xFFFF},// DYNAMIC_SEQRAM_04
	{0x3D06, 0xFFFF},// DYNAMIC_SEQRAM_06
	{0x3D08, 0x5E40},// DYNAMIC_SEQRAM_08
	{0x3D0A, 0x1146},// DYNAMIC_SEQRAM_0A
	{0x3D0C, 0x5D41},// DYNAMIC_SEQRAM_0C
	{0x3D0E, 0x1088},// DYNAMIC_SEQRAM_0E
	{0x3D10, 0x8342},// DYNAMIC_SEQRAM_10
	{0x3D12, 0x00C0},// DYNAMIC_SEQRAM_12
	{0x3D14, 0x5580},// DYNAMIC_SEQRAM_14
	{0x3D16, 0x5B83},// DYNAMIC_SEQRAM_16
	{0x3D18, 0x6084},// DYNAMIC_SEQRAM_18
	{0x3D1A, 0x5A8D},// DYNAMIC_SEQRAM_1A
	{0x3D1C, 0x00C0},// DYNAMIC_SEQRAM_1C
	{0x3D1E, 0x8342},// DYNAMIC_SEQRAM_1E
	{0x3D20, 0x925A},// DYNAMIC_SEQRAM_20
	{0x3D22, 0x8664},// DYNAMIC_SEQRAM_22
	{0x3D24, 0x1030},// DYNAMIC_SEQRAM_24
	{0x3D26, 0x801C},// DYNAMIC_SEQRAM_26
	{0x3D28, 0x00A0},// DYNAMIC_SEQRAM_28
	{0x3D2A, 0x56B0},// DYNAMIC_SEQRAM_2A
	{0x3D2C, 0x5788},// DYNAMIC_SEQRAM_2C
	{0x3D2E, 0x5150},// DYNAMIC_SEQRAM_2E
	{0x3D30, 0x824D},// DYNAMIC_SEQRAM_30
	{0x3D32, 0x8D58},// DYNAMIC_SEQRAM_32
	{0x3D34, 0x58D2},// DYNAMIC_SEQRAM_34
	{0x3D36, 0x438A},// DYNAMIC_SEQRAM_36
	{0x3D38, 0x4592},// DYNAMIC_SEQRAM_38
	{0x3D3A, 0x458A},// DYNAMIC_SEQRAM_3A
	{0x3D3C, 0x4389},// DYNAMIC_SEQRAM_3C
	{0x3D3E, 0x51FF},// DYNAMIC_SEQRAM_3E
	{0x3D40, 0x8451},// DYNAMIC_SEQRAM_40
	{0x3D42, 0x8410},// DYNAMIC_SEQRAM_42
	{0x3D44, 0x0C88},// DYNAMIC_SEQRAM_44
	{0x3D46, 0x5959},// DYNAMIC_SEQRAM_46
	{0x3D48, 0x8A5F},// DYNAMIC_SEQRAM_48
	{0x3D4A, 0xDA42},// DYNAMIC_SEQRAM_4A
	{0x3D4C, 0x9361},// DYNAMIC_SEQRAM_4C
	{0x3D4E, 0x8262},// DYNAMIC_SEQRAM_4E
	{0x3D50, 0x8342},// DYNAMIC_SEQRAM_50
	{0x3D52, 0x8010},// DYNAMIC_SEQRAM_52
	{0x3D54, 0xC041},// DYNAMIC_SEQRAM_54
	{0x3D56, 0x64FF},// DYNAMIC_SEQRAM_56
	{0x3D58, 0xFFB7},// DYNAMIC_SEQRAM_58
	{0x3D5A, 0x4081},// DYNAMIC_SEQRAM_5A
	{0x3D5C, 0x4080},// DYNAMIC_SEQRAM_5C
	{0x3D5E, 0x4180},// DYNAMIC_SEQRAM_5E
	{0x3D60, 0x4280},// DYNAMIC_SEQRAM_60
	{0x3D62, 0x438D},// DYNAMIC_SEQRAM_62
	{0x3D64, 0x44BA},// DYNAMIC_SEQRAM_64
	{0x3D66, 0x4488},// DYNAMIC_SEQRAM_66
	{0x3D68, 0x4380},// DYNAMIC_SEQRAM_68
	{0x3D6A, 0x4241},// DYNAMIC_SEQRAM_6A
	{0x3D6C, 0x8140},// DYNAMIC_SEQRAM_6C
	{0x3D6E, 0x8240},// DYNAMIC_SEQRAM_6E
	{0x3D70, 0x8041},// DYNAMIC_SEQRAM_70
	{0x3D72, 0x8042},// DYNAMIC_SEQRAM_72
	{0x3D74, 0x8043},// DYNAMIC_SEQRAM_74
	{0x3D76, 0x8D44},// DYNAMIC_SEQRAM_76
	{0x3D78, 0xBA44},// DYNAMIC_SEQRAM_78
	{0x3D7A, 0x875E},// DYNAMIC_SEQRAM_7A
	{0x3D7C, 0x4354},// DYNAMIC_SEQRAM_7C
	{0x3D7E, 0x4241},// DYNAMIC_SEQRAM_7E
	{0x3D80, 0x8140},// DYNAMIC_SEQRAM_80
	{0x3D82, 0x8120},// DYNAMIC_SEQRAM_82
	{0x3D84, 0x2881},// DYNAMIC_SEQRAM_84
	{0x3D86, 0x6026},// DYNAMIC_SEQRAM_86
	{0x3D88, 0x8055},// DYNAMIC_SEQRAM_88
	{0x3D8A, 0x8070},// DYNAMIC_SEQRAM_8A
	{0x3D8C, 0x8040},// DYNAMIC_SEQRAM_8C
	{0x3D8E, 0x4C81},// DYNAMIC_SEQRAM_8E
	{0x3D90, 0x45C3},// DYNAMIC_SEQRAM_90
	{0x3D92, 0x4581},// DYNAMIC_SEQRAM_92
	{0x3D94, 0x4C40},// DYNAMIC_SEQRAM_94
	{0x3D96, 0x8070},// DYNAMIC_SEQRAM_96
	{0x3D98, 0x8040},// DYNAMIC_SEQRAM_98
	{0x3D9A, 0x4C85},// DYNAMIC_SEQRAM_9A
	{0x3D9C, 0x6CA8},// DYNAMIC_SEQRAM_9C
	{0x3D9E, 0x6C8C},// DYNAMIC_SEQRAM_9E
	{0x3DA0, 0x000E},// DYNAMIC_SEQRAM_A0
	{0x3DA2, 0xBE44},// DYNAMIC_SEQRAM_A2
	{0x3DA4, 0x8844},// DYNAMIC_SEQRAM_A4
	{0x3DA6, 0xBC78},// DYNAMIC_SEQRAM_A6
	{0x3DA8, 0x0900},// DYNAMIC_SEQRAM_A8
	{0x3DAA, 0x8904},// DYNAMIC_SEQRAM_AA
	{0x3DAC, 0x8080},// DYNAMIC_SEQRAM_AC
	{0x3DAE, 0x0240},// DYNAMIC_SEQRAM_AE
	{0x3DB0, 0x8609},// DYNAMIC_SEQRAM_B0
	{0x3DB2, 0x008E},// DYNAMIC_SEQRAM_B2
	{0x3DB4, 0x0900},// DYNAMIC_SEQRAM_B4
	{0x3DB6, 0x8002},// DYNAMIC_SEQRAM_B6
	{0x3DB8, 0x4080},// DYNAMIC_SEQRAM_B8
	{0x3DBA, 0x0480},// DYNAMIC_SEQRAM_BA
	{0x3DBC, 0x887C},// DYNAMIC_SEQRAM_BC
	{0x3DBE, 0xAA86},// DYNAMIC_SEQRAM_BE
	{0x3DC0, 0x0900},// DYNAMIC_SEQRAM_C0
	{0x3DC2, 0x877A},// DYNAMIC_SEQRAM_C2
	{0x3DC4, 0x000E},// DYNAMIC_SEQRAM_C4
	{0x3DC6, 0xC379},// DYNAMIC_SEQRAM_C6
	{0x3DC8, 0x4C40},// DYNAMIC_SEQRAM_C8
	{0x3DCA, 0xBF70},// DYNAMIC_SEQRAM_CA
	{0x3DCC, 0x5E40},// DYNAMIC_SEQRAM_CC
	{0x3DCE, 0x114E},// DYNAMIC_SEQRAM_CE
	{0x3DD0, 0x5D41},// DYNAMIC_SEQRAM_D0
	{0x3DD2, 0x5383},// DYNAMIC_SEQRAM_D2
	{0x3DD4, 0x4200},// DYNAMIC_SEQRAM_D4
	{0x3DD6, 0xC055},// DYNAMIC_SEQRAM_D6
	{0x3DD8, 0xA400},// DYNAMIC_SEQRAM_D8
	{0x3DDA, 0xC083},// DYNAMIC_SEQRAM_DA
	{0x3DDC, 0x4288},// DYNAMIC_SEQRAM_DC
	{0x3DDE, 0x6083},// DYNAMIC_SEQRAM_DE
	{0x3DE0, 0x5B80},// DYNAMIC_SEQRAM_E0
	{0x3DE2, 0x5A64},// DYNAMIC_SEQRAM_E2
	{0x3DE4, 0x1030},// DYNAMIC_SEQRAM_E4
	{0x3DE6, 0x801C},// DYNAMIC_SEQRAM_E6
	{0x3DE8, 0x00A5},// DYNAMIC_SEQRAM_E8
	{0x3DEA, 0x5697},// DYNAMIC_SEQRAM_EA
	{0x3DEC, 0x57A5},// DYNAMIC_SEQRAM_EC
	{0x3DEE, 0x5180},// DYNAMIC_SEQRAM_EE
	{0x3DF0, 0x505A},// DYNAMIC_SEQRAM_F0
	{0x3DF2, 0x814D},// DYNAMIC_SEQRAM_F2
	{0x3DF4, 0x8358},// DYNAMIC_SEQRAM_F4
	{0x3DF6, 0x8058},// DYNAMIC_SEQRAM_F6
	{0x3DF8, 0xA943},// DYNAMIC_SEQRAM_F8
	{0x3DFA, 0x8345},// DYNAMIC_SEQRAM_FA
	{0x3DFC, 0xB045},// DYNAMIC_SEQRAM_FC
	{0x3DFE, 0x8343},// DYNAMIC_SEQRAM_FE
	{0x3E00, 0xA351},// DYNAMIC_SEQRAM_100
	{0x3E02, 0xE251},// DYNAMIC_SEQRAM_102
	{0x3E04, 0x8C59},// DYNAMIC_SEQRAM_104
	{0x3E06, 0x8059},// DYNAMIC_SEQRAM_106
	{0x3E08, 0x8A5F},// DYNAMIC_SEQRAM_108
	{0x3E0A, 0xEC7C},// DYNAMIC_SEQRAM_10A
	{0x3E0C, 0xCC84},// DYNAMIC_SEQRAM_10C
	{0x3E0E, 0x6182},// DYNAMIC_SEQRAM_10E
	{0x3E10, 0x6283},// DYNAMIC_SEQRAM_110
	{0x3E12, 0x4283},// DYNAMIC_SEQRAM_112
	{0x3E14, 0x10CC},// DYNAMIC_SEQRAM_114
	{0x3E16, 0x6496},// DYNAMIC_SEQRAM_116
	{0x3E18, 0x4281},// DYNAMIC_SEQRAM_118
	{0x3E1A, 0x41BB},// DYNAMIC_SEQRAM_11A
	{0x3E1C, 0x4082},// DYNAMIC_SEQRAM_11C
	{0x3E1E, 0x407E},// DYNAMIC_SEQRAM_11E
	{0x3E20, 0xCC41},// DYNAMIC_SEQRAM_120
	{0x3E22, 0x8042},// DYNAMIC_SEQRAM_122
	{0x3E24, 0x8043},// DYNAMIC_SEQRAM_124
	{0x3E26, 0x8300},// DYNAMIC_SEQRAM_126
	{0x3E28, 0xC088},// DYNAMIC_SEQRAM_128
	{0x3E2A, 0x44BA},// DYNAMIC_SEQRAM_12A
	{0x3E2C, 0x4488},// DYNAMIC_SEQRAM_12C
	{0x3E2E, 0x00C8},// DYNAMIC_SEQRAM_12E
	{0x3E30, 0x8042},// DYNAMIC_SEQRAM_130
	{0x3E32, 0x4181},// DYNAMIC_SEQRAM_132
	{0x3E34, 0x4082},// DYNAMIC_SEQRAM_134
	{0x3E36, 0x4080},// DYNAMIC_SEQRAM_136
	{0x3E38, 0x4180},// DYNAMIC_SEQRAM_138
	{0x3E3A, 0x4280},// DYNAMIC_SEQRAM_13A
	{0x3E3C, 0x4383},// DYNAMIC_SEQRAM_13C
	{0x3E3E, 0x00C0},// DYNAMIC_SEQRAM_13E
	{0x3E40, 0x8844},// DYNAMIC_SEQRAM_140
	{0x3E42, 0xBA44},// DYNAMIC_SEQRAM_142
	{0x3E44, 0x8800},// DYNAMIC_SEQRAM_144
	{0x3E46, 0xC880},// DYNAMIC_SEQRAM_146
	{0x3E48, 0x4241},// DYNAMIC_SEQRAM_148
	{0x3E4A, 0x8240},// DYNAMIC_SEQRAM_14A
	{0x3E4C, 0x8140},// DYNAMIC_SEQRAM_14C
	{0x3E4E, 0x8041},// DYNAMIC_SEQRAM_14E
	{0x3E50, 0x8042},// DYNAMIC_SEQRAM_150
	{0x3E52, 0x8043},// DYNAMIC_SEQRAM_152
	{0x3E54, 0x8300},// DYNAMIC_SEQRAM_154
	{0x3E56, 0xC088},// DYNAMIC_SEQRAM_156
	{0x3E58, 0x44BA},// DYNAMIC_SEQRAM_158
	{0x3E5A, 0x4488},// DYNAMIC_SEQRAM_15A
	{0x3E5C, 0x00C8},// DYNAMIC_SEQRAM_15C
	{0x3E5E, 0x8042},// DYNAMIC_SEQRAM_15E
	{0x3E60, 0x4181},// DYNAMIC_SEQRAM_160
	{0x3E62, 0x4082},// DYNAMIC_SEQRAM_162
	{0x3E64, 0x4080},// DYNAMIC_SEQRAM_164
	{0x3E66, 0x4180},// DYNAMIC_SEQRAM_166
	{0x3E68, 0x4280},// DYNAMIC_SEQRAM_168
	{0x3E6A, 0x4383},// DYNAMIC_SEQRAM_16A
	{0x3E6C, 0x00C0},// DYNAMIC_SEQRAM_16C
	{0x3E6E, 0x8844},// DYNAMIC_SEQRAM_16E
	{0x3E70, 0xBA44},// DYNAMIC_SEQRAM_170
	{0x3E72, 0x8800},// DYNAMIC_SEQRAM_172
	{0x3E74, 0xC880},// DYNAMIC_SEQRAM_174
	{0x3E76, 0x4241},// DYNAMIC_SEQRAM_176
	{0x3E78, 0x8140},// DYNAMIC_SEQRAM_178
	{0x3E7A, 0x9F5E},// DYNAMIC_SEQRAM_17A
	{0x3E7C, 0x8A54},// DYNAMIC_SEQRAM_17C
	{0x3E7E, 0x8620},// DYNAMIC_SEQRAM_17E
	{0x3E80, 0x2881},// DYNAMIC_SEQRAM_180
	{0x3E82, 0x6026},// DYNAMIC_SEQRAM_182
	{0x3E84, 0x8055},// DYNAMIC_SEQRAM_184
	{0x3E86, 0x8070},// DYNAMIC_SEQRAM_186
	{0x3E88, 0x0000},// DYNAMIC_SEQRAM_188
	{0x3E8A, 0x0000},// DYNAMIC_SEQRAM_18A
	{0x3E8C, 0x0000},// DYNAMIC_SEQRAM_18C
	{0x3E8E, 0x0000},// DYNAMIC_SEQRAM_18E
	{0x3E90, 0x0000},// DYNAMIC_SEQRAM_190
	{0x3E92, 0x0000},// DYNAMIC_SEQRAM_192
	{0x3E94, 0x0000},// DYNAMIC_SEQRAM_194
	{0x3E96, 0x0000},// DYNAMIC_SEQRAM_196
	{0x3E98, 0x0000},// DYNAMIC_SEQRAM_198
	{0x3E9A, 0x0000},// DYNAMIC_SEQRAM_19A
	{0x3E9C, 0x0000},// DYNAMIC_SEQRAM_19C
	{0x3E9E, 0x0000},// DYNAMIC_SEQRAM_19E
	{0x3EA0, 0x0000},// DYNAMIC_SEQRAM_1A0
	{0x3EA2, 0x0000},// DYNAMIC_SEQRAM_1A2
	{0x3EA4, 0x0000},// DYNAMIC_SEQRAM_1A4
	{0x3EA6, 0x0000},// DYNAMIC_SEQRAM_1A6
	{0x3EA8, 0x0000},// DYNAMIC_SEQRAM_1A8
	{0x3EAA, 0x0000},// DYNAMIC_SEQRAM_1AA
	{0x3EAC, 0x0000},// DYNAMIC_SEQRAM_1AC
	{0x3EAE, 0x0000},// DYNAMIC_SEQRAM_1AE
	{0x3EB0, 0x0000},// DYNAMIC_SEQRAM_1B0
	{0x3EB2, 0x0000},// DYNAMIC_SEQRAM_1B2
	{0x3EB4, 0x0000},// DYNAMIC_SEQRAM_1B4
	{0x3EB6, 0x004D},// DAC_LD_0_1
	{0x3EBC, 0xAA06},// DAC_LD_6_7
	{0x3EC0, 0x2E02},// DAC_LD_10_11
	{0x3EC2, 0x7700},// DAC_LD_12_13
	{0x3EC4, 0x1C08},// DAC_LD_14_15
	{0x3EC6, 0xEA44},// DAC_LD_16_17
	{0x3EC8, 0x0F0F},// DAC_LD_18_19
	{0x3ECA, 0x0F4A},// DAC_LD_20_21
	{0x3ECC, 0x0706},// DAC_LD_22_23
	{0x3ECE, 0x443B},// DAC_LD_24_25
	{0x3ED0, 0x12F0},// DAC_LD_26_27
	{0x3ED2, 0x0039},// DAC_LD_28_29
	{0x3ED4, 0x862F},// DAC_LD_30_31
	{0x3ED6, 0x4080},// DAC_LD_32_33
	{0x3ED8, 0x0523},// DAC_LD_34_35
	{0x3EDA, 0xF8AA},// DAC_LD_36_37
	{0x3EDC, 0x5078},// DAC_LD_38_39
	{0x3EDE, 0x5005},// DAC_LD_40_41
	{0x316A, 0x8200},// DAC_RSTLO
	{0x316E, 0x8200},// DAC_ECL
	{0x316C, 0x8200},// DAC_TXLO
	{0x3EF0, 0x414D},// DAC_LD_ECL
	{0x3EF2, 0x0101},// DAC_LD_FSC
	{0x3EF6, 0x0307},// DAC_LD_RSTD
	{0x3EFA, 0x0F0F},// DAC_LD_TXLO
	{0x3EFC, 0x0F0F},// DAC_LD_TXLO1
	{0x3EFE, 0x0F0F},// DAC_LD_TXLO2
	{0x31B0, 0x005C}, // FRAME_PREAMBLE
	{0x31B2, 0x002D}, // LINE_PREAMBLE
	{0x31B4, 0x4392}, // MIPI_TIMING_0
	{0x31B6, 0x43CA}, // MIPI_TIMING_1
	{0x31B8, 0x2413}, // MIPI_TIMING_2
	{0x31BA, 0x1C70}, // MIPI_TIMING_3
	{0x31BC, 0x868B}, // MIPI_TIMING_4
	{0x0300, 0x0005}, // VT_PIX_CLK_DIV
	{0x0302, 0x0001}, // VT_SYS_CLK_DIV
	{0x0304, 0x0303}, // PRE_PLL_CLK_DIV
	{0x0306, 0x2C2C}, // PLL_MULTIPLIER
	{0x0308, 0x000A}, // OP_PIX_CLK_DIV
	{0x030A, 0x0001}, // OP_SYS_CLK_DIV
	{0x3016, 0x0111}, // ROW_SPEED
	{0x31AE, 0x0204}, // SERIAL_FORMAT
	{0x0112, 0x0A0A}, // CCP_DATA_FORMAT
	{0x0344, 0x00C8},// X_ADDR_START
	{0x0348, 0x0FC7},// X_ADDR_END
	{0x0346, 0x01F0},// Y_ADDR_START
	{0x034A, 0x0A5F},// Y_ADDR_END
	{0x034C, 0x0F00},// X_OUTPUT_SIZE
	{0x034E, 0x0870},// Y_OUTPUT_SIZE
	{0x3040, 0x0041},// READ_MODE
	{0x0112, 0x0A0A},// CCP_DATA_FORMAT
	{0x0112, 0x0A0A},// CCP_DATA_FORMAT
	{0x3172, 0x0206},// ANALOG_CONTROL2
	{0x317A, 0x416E},// ANALOG_CONTROL6
	{0x3F3C, 0x0003},// ANALOG_CONTROL9
	{0x0342, 0x1230},// LINE_LENGTH_PCK
	{0x0340, 0x0BCC},// FRAME_LENGTH_LINES
	{0x0202, 0x0AA0},// COARSE_INTEGRATION_TIME
	{0x30FE, 0x0060},// CTREE_OFF
	{0x31E0, 0x0781},// PIX_DEF_ID
	{0x3F00, 0x004F},// BM_T0
	{0x3F02, 0x0125},// BM_T1
	{0x3F04, 0x0020},// NOISE_GAIN_THRESHOLD0
	{0x3F06, 0x0040},// NOISE_GAIN_THRESHOLD1
	{0x3F08, 0x0070},// NOISE_GAIN_THRESHOLD2
	{0x3F0A, 0x0101},// NOISE_FLOOR10
	{0x3F0C, 0x0302},// NOISE_FLOOR32
	{0x3F1E, 0x0022},// NOISE_COEF
	{0x3F1A, 0x01FF},// CROSSFACTOR2
	{0x3F14, 0x0101},// SINGLE_K_FACTOR2
	{0x3F44, 0x0707},// COUPLE_K_FACTOR2
	{0x3F18, 0x011E},// CROSSFACTOR1
	{0x3F12, 0x0303},// SINGLE_K_FACTOR1
	{0x3F42, 0x1511},// COUPLE_K_FACTOR1
	{0x3F16, 0x011E},// CROSSFACTOR0
	{0x3F10, 0x0505},// SINGLE_K_FACTOR0
	{0x3F40, 0x1511},// COUPLE_K_FACTOR0
	{0x3F3C, 0x0003},// ANALOG_CONTROL9
	{0x301A, 0x021C},// RESET_REGISTER
};

static const struct regval_list ar1335_2048x1536_30fps_raw10_48Mxclk[] = {
	{0x301A, 0x0219}, // RESET_REGISTER
	{REG_DELAY, 10},
	{0x3042, 0x1004}, // DARK_CONTROL2
	{0x30D2, 0x0120}, // CRM_CONTROL
	{0x30D4, 0x0000}, // COLUMN_CORRECTION
	{0x3090, 0x0000}, // RNF_CONTROL
	{0x30FC, 0x0060}, // MODULE_CLK_OFF
	{0x30FE, 0x0060}, // CTREE_OFF
	{0x31E0, 0x0781}, // PIX_DEF_ID
	{0x3180, 0x9434}, // FINE_DIG_CORRECTION_CONTROL
	{0x317C, 0xEFF4}, // ANALOG_CONTROL7
	{0x30EE, 0x613E}, // DARK_CONTROL3
	{0x3F2C, 0x4428}, // GTH_THRES_RTN
	{0x3D00, 0x0446}, // DYNAMIC_SEQRAM_00
	{0x3D02, 0x4C66}, // DYNAMIC_SEQRAM_02
	{0x3D04, 0xFFFF}, // DYNAMIC_SEQRAM_04
	{0x3D06, 0xFFFF}, // DYNAMIC_SEQRAM_06
	{0x3D08, 0x5E40}, // DYNAMIC_SEQRAM_08
	{0x3D0A, 0x1146}, // DYNAMIC_SEQRAM_0A
	{0x3D0C, 0x5D41}, // DYNAMIC_SEQRAM_0C
	{0x3D0E, 0x1088}, // DYNAMIC_SEQRAM_0E
	{0x3D10, 0x8342}, // DYNAMIC_SEQRAM_10
	{0x3D12, 0x00C0}, // DYNAMIC_SEQRAM_12
	{0x3D14, 0x5580}, // DYNAMIC_SEQRAM_14
	{0x3D16, 0x5B83}, // DYNAMIC_SEQRAM_16
	{0x3D18, 0x6084}, // DYNAMIC_SEQRAM_18
	{0x3D1A, 0x5A8D}, // DYNAMIC_SEQRAM_1A
	{0x3D1C, 0x00C0}, // DYNAMIC_SEQRAM_1C
	{0x3D1E, 0x8342}, // DYNAMIC_SEQRAM_1E
	{0x3D20, 0x925A}, // DYNAMIC_SEQRAM_20
	{0x3D22, 0x8664}, // DYNAMIC_SEQRAM_22
	{0x3D24, 0x1030}, // DYNAMIC_SEQRAM_24
	{0x3D26, 0x801C}, // DYNAMIC_SEQRAM_26
	{0x3D28, 0x00A0}, // DYNAMIC_SEQRAM_28
	{0x3D2A, 0x56B0}, // DYNAMIC_SEQRAM_2A
	{0x3D2C, 0x5788}, // DYNAMIC_SEQRAM_2C
	{0x3D2E, 0x5150}, // DYNAMIC_SEQRAM_2E
	{0x3D30, 0x824D}, // DYNAMIC_SEQRAM_30
	{0x3D32, 0x8D58}, // DYNAMIC_SEQRAM_32
	{0x3D34, 0x58D2}, // DYNAMIC_SEQRAM_34
	{0x3D36, 0x438A}, // DYNAMIC_SEQRAM_36
	{0x3D38, 0x4592}, // DYNAMIC_SEQRAM_38
	{0x3D3A, 0x458A}, // DYNAMIC_SEQRAM_3A
	{0x3D3C, 0x4389}, // DYNAMIC_SEQRAM_3C
	{0x3D3E, 0x51FF}, // DYNAMIC_SEQRAM_3E
	{0x3D40, 0x8451}, // DYNAMIC_SEQRAM_40
	{0x3D42, 0x8410}, // DYNAMIC_SEQRAM_42
	{0x3D44, 0x0C88}, // DYNAMIC_SEQRAM_44
	{0x3D46, 0x5959}, // DYNAMIC_SEQRAM_46
	{0x3D48, 0x8A5F}, // DYNAMIC_SEQRAM_48
	{0x3D4A, 0xDA42}, // DYNAMIC_SEQRAM_4A
	{0x3D4C, 0x9361}, // DYNAMIC_SEQRAM_4C
	{0x3D4E, 0x8262}, // DYNAMIC_SEQRAM_4E
	{0x3D50, 0x8342}, // DYNAMIC_SEQRAM_50
	{0x3D52, 0x8010}, // DYNAMIC_SEQRAM_52
	{0x3D54, 0xC041}, // DYNAMIC_SEQRAM_54
	{0x3D56, 0x64FF}, // DYNAMIC_SEQRAM_56
	{0x3D58, 0xFFB7}, // DYNAMIC_SEQRAM_58
	{0x3D5A, 0x4081}, // DYNAMIC_SEQRAM_5A
	{0x3D5C, 0x4080}, // DYNAMIC_SEQRAM_5C
	{0x3D5E, 0x4180}, // DYNAMIC_SEQRAM_5E
	{0x3D60, 0x4280}, // DYNAMIC_SEQRAM_60
	{0x3D62, 0x438D}, // DYNAMIC_SEQRAM_62
	{0x3D64, 0x44BA}, // DYNAMIC_SEQRAM_64
	{0x3D66, 0x4488}, // DYNAMIC_SEQRAM_66
	{0x3D68, 0x4380}, // DYNAMIC_SEQRAM_68
	{0x3D6A, 0x4241}, // DYNAMIC_SEQRAM_6A
	{0x3D6C, 0x8140}, // DYNAMIC_SEQRAM_6C
	{0x3D6E, 0x8240}, // DYNAMIC_SEQRAM_6E
	{0x3D70, 0x8041}, // DYNAMIC_SEQRAM_70
	{0x3D72, 0x8042}, // DYNAMIC_SEQRAM_72
	{0x3D74, 0x8043}, // DYNAMIC_SEQRAM_74
	{0x3D76, 0x8D44}, // DYNAMIC_SEQRAM_76
	{0x3D78, 0xBA44}, // DYNAMIC_SEQRAM_78
	{0x3D7A, 0x875E}, // DYNAMIC_SEQRAM_7A
	{0x3D7C, 0x4354}, // DYNAMIC_SEQRAM_7C
	{0x3D7E, 0x4241}, // DYNAMIC_SEQRAM_7E
	{0x3D80, 0x8140}, // DYNAMIC_SEQRAM_80
	{0x3D82, 0x8120}, // DYNAMIC_SEQRAM_82
	{0x3D84, 0x2881}, // DYNAMIC_SEQRAM_84
	{0x3D86, 0x6026}, // DYNAMIC_SEQRAM_86
	{0x3D88, 0x8055}, // DYNAMIC_SEQRAM_88
	{0x3D8A, 0x8070}, // DYNAMIC_SEQRAM_8A
	{0x3D8C, 0x8040}, // DYNAMIC_SEQRAM_8C
	{0x3D8E, 0x4C81}, // DYNAMIC_SEQRAM_8E
	{0x3D90, 0x45C3}, // DYNAMIC_SEQRAM_90
	{0x3D92, 0x4581}, // DYNAMIC_SEQRAM_92
	{0x3D94, 0x4C40}, // DYNAMIC_SEQRAM_94
	{0x3D96, 0x8070}, // DYNAMIC_SEQRAM_96
	{0x3D98, 0x8040}, // DYNAMIC_SEQRAM_98
	{0x3D9A, 0x4C85}, // DYNAMIC_SEQRAM_9A
	{0x3D9C, 0x6CA8}, // DYNAMIC_SEQRAM_9C
	{0x3D9E, 0x6C8C}, // DYNAMIC_SEQRAM_9E
	{0x3DA0, 0x000E}, // DYNAMIC_SEQRAM_A0
	{0x3DA2, 0xBE44}, // DYNAMIC_SEQRAM_A2
	{0x3DA4, 0x8844}, // DYNAMIC_SEQRAM_A4
	{0x3DA6, 0xBC78}, // DYNAMIC_SEQRAM_A6
	{0x3DA8, 0x0900}, // DYNAMIC_SEQRAM_A8
	{0x3DAA, 0x8904}, // DYNAMIC_SEQRAM_AA
	{0x3DAC, 0x8080}, // DYNAMIC_SEQRAM_AC
	{0x3DAE, 0x0240}, // DYNAMIC_SEQRAM_AE
	{0x3DB0, 0x8609}, // DYNAMIC_SEQRAM_B0
	{0x3DB2, 0x008E}, // DYNAMIC_SEQRAM_B2
	{0x3DB4, 0x0900}, // DYNAMIC_SEQRAM_B4
	{0x3DB6, 0x8002}, // DYNAMIC_SEQRAM_B6
	{0x3DB8, 0x4080}, // DYNAMIC_SEQRAM_B8
	{0x3DBA, 0x0480}, // DYNAMIC_SEQRAM_BA
	{0x3DBC, 0x887C}, // DYNAMIC_SEQRAM_BC
	{0x3DBE, 0xAA86}, // DYNAMIC_SEQRAM_BE
	{0x3DC0, 0x0900}, // DYNAMIC_SEQRAM_C0
	{0x3DC2, 0x877A}, // DYNAMIC_SEQRAM_C2
	{0x3DC4, 0x000E}, // DYNAMIC_SEQRAM_C4
	{0x3DC6, 0xC379}, // DYNAMIC_SEQRAM_C6
	{0x3DC8, 0x4C40}, // DYNAMIC_SEQRAM_C8
	{0x3DCA, 0xBF70}, // DYNAMIC_SEQRAM_CA
	{0x3DCC, 0x5E40}, // DYNAMIC_SEQRAM_CC
	{0x3DCE, 0x114E}, // DYNAMIC_SEQRAM_CE
	{0x3DD0, 0x5D41}, // DYNAMIC_SEQRAM_D0
	{0x3DD2, 0x5383}, // DYNAMIC_SEQRAM_D2
	{0x3DD4, 0x4200}, // DYNAMIC_SEQRAM_D4
	{0x3DD6, 0xC055}, // DYNAMIC_SEQRAM_D6
	{0x3DD8, 0xA400}, // DYNAMIC_SEQRAM_D8
	{0x3DDA, 0xC083}, // DYNAMIC_SEQRAM_DA
	{0x3DDC, 0x4288}, // DYNAMIC_SEQRAM_DC
	{0x3DDE, 0x6083}, // DYNAMIC_SEQRAM_DE
	{0x3DE0, 0x5B80}, // DYNAMIC_SEQRAM_E0
	{0x3DE2, 0x5A64}, // DYNAMIC_SEQRAM_E2
	{0x3DE4, 0x1030}, // DYNAMIC_SEQRAM_E4
	{0x3DE6, 0x801C}, // DYNAMIC_SEQRAM_E6
	{0x3DE8, 0x00A5}, // DYNAMIC_SEQRAM_E8
	{0x3DEA, 0x5697}, // DYNAMIC_SEQRAM_EA
	{0x3DEC, 0x57A5}, // DYNAMIC_SEQRAM_EC
	{0x3DEE, 0x5180}, // DYNAMIC_SEQRAM_EE
	{0x3DF0, 0x505A}, // DYNAMIC_SEQRAM_F0
	{0x3DF2, 0x814D}, // DYNAMIC_SEQRAM_F2
	{0x3DF4, 0x8358}, // DYNAMIC_SEQRAM_F4
	{0x3DF6, 0x8058}, // DYNAMIC_SEQRAM_F6
	{0x3DF8, 0xA943}, // DYNAMIC_SEQRAM_F8
	{0x3DFA, 0x8345}, // DYNAMIC_SEQRAM_FA
	{0x3DFC, 0xB045}, // DYNAMIC_SEQRAM_FC
	{0x3DFE, 0x8343}, // DYNAMIC_SEQRAM_FE
	{0x3E00, 0xA351}, // DYNAMIC_SEQRAM_100
	{0x3E02, 0xE251}, // DYNAMIC_SEQRAM_102
	{0x3E04, 0x8C59}, // DYNAMIC_SEQRAM_104
	{0x3E06, 0x8059}, // DYNAMIC_SEQRAM_106
	{0x3E08, 0x8A5F}, // DYNAMIC_SEQRAM_108
	{0x3E0A, 0xEC7C}, // DYNAMIC_SEQRAM_10A
	{0x3E0C, 0xCC84}, // DYNAMIC_SEQRAM_10C
	{0x3E0E, 0x6182}, // DYNAMIC_SEQRAM_10E
	{0x3E10, 0x6283}, // DYNAMIC_SEQRAM_110
	{0x3E12, 0x4283}, // DYNAMIC_SEQRAM_112
	{0x3E14, 0x10CC}, // DYNAMIC_SEQRAM_114
	{0x3E16, 0x6496}, // DYNAMIC_SEQRAM_116
	{0x3E18, 0x4281}, // DYNAMIC_SEQRAM_118
	{0x3E1A, 0x41BB}, // DYNAMIC_SEQRAM_11A
	{0x3E1C, 0x4082}, // DYNAMIC_SEQRAM_11C
	{0x3E1E, 0x407E}, // DYNAMIC_SEQRAM_11E
	{0x3E20, 0xCC41}, // DYNAMIC_SEQRAM_120
	{0x3E22, 0x8042}, // DYNAMIC_SEQRAM_122
	{0x3E24, 0x8043}, // DYNAMIC_SEQRAM_124
	{0x3E26, 0x8300}, // DYNAMIC_SEQRAM_126
	{0x3E28, 0xC088}, // DYNAMIC_SEQRAM_128
	{0x3E2A, 0x44BA}, // DYNAMIC_SEQRAM_12A
	{0x3E2C, 0x4488}, // DYNAMIC_SEQRAM_12C
	{0x3E2E, 0x00C8}, // DYNAMIC_SEQRAM_12E
	{0x3E30, 0x8042}, // DYNAMIC_SEQRAM_130
	{0x3E32, 0x4181}, // DYNAMIC_SEQRAM_132
	{0x3E34, 0x4082}, // DYNAMIC_SEQRAM_134
	{0x3E36, 0x4080}, // DYNAMIC_SEQRAM_136
	{0x3E38, 0x4180}, // DYNAMIC_SEQRAM_138
	{0x3E3A, 0x4280}, // DYNAMIC_SEQRAM_13A
	{0x3E3C, 0x4383}, // DYNAMIC_SEQRAM_13C
	{0x3E3E, 0x00C0}, // DYNAMIC_SEQRAM_13E
	{0x3E40, 0x8844}, // DYNAMIC_SEQRAM_140
	{0x3E42, 0xBA44}, // DYNAMIC_SEQRAM_142
	{0x3E44, 0x8800}, // DYNAMIC_SEQRAM_144
	{0x3E46, 0xC880}, // DYNAMIC_SEQRAM_146
	{0x3E48, 0x4241}, // DYNAMIC_SEQRAM_148
	{0x3E4A, 0x8240}, // DYNAMIC_SEQRAM_14A
	{0x3E4C, 0x8140}, // DYNAMIC_SEQRAM_14C
	{0x3E4E, 0x8041}, // DYNAMIC_SEQRAM_14E
	{0x3E50, 0x8042}, // DYNAMIC_SEQRAM_150
	{0x3E52, 0x8043}, // DYNAMIC_SEQRAM_152
	{0x3E54, 0x8300}, // DYNAMIC_SEQRAM_154
	{0x3E56, 0xC088}, // DYNAMIC_SEQRAM_156
	{0x3E58, 0x44BA}, // DYNAMIC_SEQRAM_158
	{0x3E5A, 0x4488}, // DYNAMIC_SEQRAM_15A
	{0x3E5C, 0x00C8}, // DYNAMIC_SEQRAM_15C
	{0x3E5E, 0x8042}, // DYNAMIC_SEQRAM_15E
	{0x3E60, 0x4181}, // DYNAMIC_SEQRAM_160
	{0x3E62, 0x4082}, // DYNAMIC_SEQRAM_162
	{0x3E64, 0x4080}, // DYNAMIC_SEQRAM_164
	{0x3E66, 0x4180}, // DYNAMIC_SEQRAM_166
	{0x3E68, 0x4280}, // DYNAMIC_SEQRAM_168
	{0x3E6A, 0x4383}, // DYNAMIC_SEQRAM_16A
	{0x3E6C, 0x00C0}, // DYNAMIC_SEQRAM_16C
	{0x3E6E, 0x8844}, // DYNAMIC_SEQRAM_16E
	{0x3E70, 0xBA44}, // DYNAMIC_SEQRAM_170
	{0x3E72, 0x8800}, // DYNAMIC_SEQRAM_172
	{0x3E74, 0xC880}, // DYNAMIC_SEQRAM_174
	{0x3E76, 0x4241}, // DYNAMIC_SEQRAM_176
	{0x3E78, 0x8140}, // DYNAMIC_SEQRAM_178
	{0x3E7A, 0x9F5E}, // DYNAMIC_SEQRAM_17A
	{0x3E7C, 0x8A54}, // DYNAMIC_SEQRAM_17C
	{0x3E7E, 0x8620}, // DYNAMIC_SEQRAM_17E
	{0x3E80, 0x2881}, // DYNAMIC_SEQRAM_180
	{0x3E82, 0x6026}, // DYNAMIC_SEQRAM_182
	{0x3E84, 0x8055}, // DYNAMIC_SEQRAM_184
	{0x3E86, 0x8070}, // DYNAMIC_SEQRAM_186
	{0x3E88, 0x0000}, // DYNAMIC_SEQRAM_188
	{0x3E8A, 0x0000}, // DYNAMIC_SEQRAM_18A
	{0x3E8C, 0x0000}, // DYNAMIC_SEQRAM_18C
	{0x3E8E, 0x0000}, // DYNAMIC_SEQRAM_18E
	{0x3E90, 0x0000}, // DYNAMIC_SEQRAM_190
	{0x3E92, 0x0000}, // DYNAMIC_SEQRAM_192
	{0x3E94, 0x0000}, // DYNAMIC_SEQRAM_194
	{0x3E96, 0x0000}, // DYNAMIC_SEQRAM_196
	{0x3E98, 0x0000}, // DYNAMIC_SEQRAM_198
	{0x3E9A, 0x0000}, // DYNAMIC_SEQRAM_19A
	{0x3E9C, 0x0000}, // DYNAMIC_SEQRAM_19C
	{0x3E9E, 0x0000}, // DYNAMIC_SEQRAM_19E
	{0x3EA0, 0x0000}, // DYNAMIC_SEQRAM_1A0
	{0x3EA2, 0x0000}, // DYNAMIC_SEQRAM_1A2
	{0x3EA4, 0x0000}, // DYNAMIC_SEQRAM_1A4
	{0x3EA6, 0x0000}, // DYNAMIC_SEQRAM_1A6
	{0x3EA8, 0x0000}, // DYNAMIC_SEQRAM_1A8
	{0x3EAA, 0x0000}, // DYNAMIC_SEQRAM_1AA
	{0x3EAC, 0x0000}, // DYNAMIC_SEQRAM_1AC
	{0x3EAE, 0x0000}, // DYNAMIC_SEQRAM_1AE
	{0x3EB0, 0x0000}, // DYNAMIC_SEQRAM_1B0
	{0x3EB2, 0x0000}, // DYNAMIC_SEQRAM_1B2
	{0x3EB4, 0x0000}, // DYNAMIC_SEQRAM_1B4
	{0x3EB6, 0x004D}, // DAC_LD_0_1
	{0x3EBC, 0xAA06}, // DAC_LD_6_7
	{0x3EC0, 0x2E02}, // DAC_LD_10_11
	{0x3EC2, 0x7700}, // DAC_LD_12_13
	{0x3EC4, 0x1C08}, // DAC_LD_14_15
	{0x3EC6, 0xEA44}, // DAC_LD_16_17
	{0x3EC8, 0x0F0F}, // DAC_LD_18_19
	{0x3ECA, 0x0F4A}, // DAC_LD_20_21
	{0x3ECC, 0x0706}, // DAC_LD_22_23
	{0x3ECE, 0x443B}, // DAC_LD_24_25
	{0x3ED0, 0x12F0}, // DAC_LD_26_27
	{0x3ED2, 0x0039}, // DAC_LD_28_29
	{0x3ED4, 0x862F}, // DAC_LD_30_31
	{0x3ED6, 0x4080}, // DAC_LD_32_33
	{0x3ED8, 0x0523}, // DAC_LD_34_35
	{0x3EDA, 0xF8AA}, // DAC_LD_36_37
	{0x3EDC, 0x5078}, // DAC_LD_38_39
	{0x3EDE, 0x5005}, // DAC_LD_40_41
	{0x316A, 0x8200}, // DAC_RSTLO
	{0x316E, 0x8200}, // DAC_ECL
	{0x316C, 0x8200}, // DAC_TXLO
	{0x3EF0, 0x414D}, // DAC_LD_ECL
	{0x3EF2, 0x0101}, // DAC_LD_FSC
	{0x3EF6, 0x0307}, // DAC_LD_RSTD
	{0x3EFA, 0x0F0F}, // DAC_LD_TXLO
	{0x3EFC, 0x0F0F}, // DAC_LD_TXLO1
	{0x3EFE, 0x0F0F}, // DAC_LD_TXLO2
	{0x31B0, 0x004D}, // FRAME_PREAMBLE
	{0x31B2, 0x0028}, // LINE_PREAMBLE
	{0x31B4, 0x230E}, // MIPI_TIMING_0
	{0x31B6, 0x1348}, // MIPI_TIMING_1
	{0x31B8, 0x1C12}, // MIPI_TIMING_2
	{0x31BA, 0x185B}, // MIPI_TIMING_3
	{0x31BC, 0x8509}, // MIPI_TIMING_4
	{0x0300, 0x0004}, // VT_PIX_CLK_DIV
	{0x0302, 0x0001}, // VT_SYS_CLK_DIV
	{0x0304, 0x0A0A}, // PRE_PLL_CLK_DIV
	{0x0306, 0xB7B7}, // PLL_MULTIPLIER	MCLK,48M
	{0x0308, 0x000A}, // OP_PIX_CLK_DIV
	{0x030A, 0x0001}, // OP_SYS_CLK_DIV
	{0x0112, 0x0A0A}, // CCP_DATA_FORMAT
	{0x3016, 0x0101}, // ROW_SPEED
	{0x0344, 0x0028}, // X_ADDR_START
	{0x0348, 0x1027}, // X_ADDR_END
	{0x0346, 0x0020}, // Y_ADDR_START
	{0x034A, 0x0C1D}, // Y_ADDR_END
	{0x034C, 0x0800}, // X_OUTPUT_SIZE
	{0x034E, 0x0600}, // Y_OUTPUT_SIZE
	{0x3040, 0x0043}, // READ_MODE
	{0x3172, 0x0206}, // ANALOG_CONTROL2
	{0x317A, 0x516E}, // ANALOG_CONTROL6
	{0x3F3C, 0x0003}, // ANALOG_CONTROL9
	{0x0400, 0x0001}, // SCALING_MODE
	{0x0404, 0x0020}, // SCALE_M
	{0x0342, 0x1230}, // LINE_LENGTH_PCK
	{0x0340, 0x0C4E}, // FRAME_LENGTH_LINES
	{0x0202, 0x0C4E}, // COARSE_INTEGRATION_TIME
	{0x30FE, 0x0060}, // CTREE_OFF
	{0x31E0, 0x0781}, // PIX_DEF_ID
	{0x3F00, 0x004F}, // BM_T0
	{0x3F02, 0x0125}, // BM_T1
	{0x3F04, 0x0020}, // NOISE_GAIN_THRESHOLD0
	{0x3F06, 0x0040}, // NOISE_GAIN_THRESHOLD1
	{0x3F08, 0x0070}, // NOISE_GAIN_THRESHOLD2
	{0x3F0A, 0x0101}, // NOISE_FLOOR10
	{0x3F0C, 0x0302}, // NOISE_FLOOR32
	{0x3F1E, 0x0022}, // NOISE_COEF
	{0x3F1A, 0x01FF}, // CROSSFACTOR2
	{0x3F14, 0x0101}, // SINGLE_K_FACTOR2
	{0x3F44, 0x0707}, // COUPLE_K_FACTOR2
	{0x3F18, 0x011E}, // CROSSFACTOR1
	{0x3F12, 0x0303}, // SINGLE_K_FACTOR1
	{0x3F42, 0x1511}, // COUPLE_K_FACTOR1
	{0x3F16, 0x011E}, // CROSSFACTOR0
	{0x3F10, 0x0505}, // SINGLE_K_FACTOR0
	{0x3F40, 0x1511}, // COUPLE_K_FACTOR0
	{0x3F3C, 0x0003}, // ANALOG_CONTROL9
	{0x301A, 0x021C}, // RESET_REGISTER
};

static const struct regval_list ar1335_1920x1080_30fps_raw10_48Mxclk[] = {
	{0x301A, 0x0219}, // RESET_REGISTER
	{REG_DELAY, 10},
	{0x3042, 0x1004}, // DARK_CONTROL2
	{0x30D2, 0x0120}, // CRM_CONTROL
	{0x30D4, 0x0000}, // COLUMN_CORRECTION
	{0x3090, 0x0000}, // RNF_CONTROL
	{0x30FC, 0x0060}, // MODULE_CLK_OFF
	{0x30FE, 0x0060}, // CTREE_OFF
	{0x31E0, 0x0781}, // PIX_DEF_ID
	{0x3180, 0x9434}, // FINE_DIG_CORRECTION_CONTROL
	{0x317C, 0xEFF4}, // ANALOG_CONTROL7
	{0x30EE, 0x613E}, // DARK_CONTROL3
	{0x3F2C, 0x4428}, // GTH_THRES_RTN
	{0x3D00, 0x0446}, // DYNAMIC_SEQRAM_00
	{0x3D02, 0x4C66}, // DYNAMIC_SEQRAM_02
	{0x3D04, 0xFFFF}, // DYNAMIC_SEQRAM_04
	{0x3D06, 0xFFFF}, // DYNAMIC_SEQRAM_06
	{0x3D08, 0x5E40}, // DYNAMIC_SEQRAM_08
	{0x3D0A, 0x1146}, // DYNAMIC_SEQRAM_0A
	{0x3D0C, 0x5D41}, // DYNAMIC_SEQRAM_0C
	{0x3D0E, 0x1088}, // DYNAMIC_SEQRAM_0E
	{0x3D10, 0x8342}, // DYNAMIC_SEQRAM_10
	{0x3D12, 0x00C0}, // DYNAMIC_SEQRAM_12
	{0x3D14, 0x5580}, // DYNAMIC_SEQRAM_14
	{0x3D16, 0x5B83}, // DYNAMIC_SEQRAM_16
	{0x3D18, 0x6084}, // DYNAMIC_SEQRAM_18
	{0x3D1A, 0x5A8D}, // DYNAMIC_SEQRAM_1A
	{0x3D1C, 0x00C0}, // DYNAMIC_SEQRAM_1C
	{0x3D1E, 0x8342}, // DYNAMIC_SEQRAM_1E
	{0x3D20, 0x925A}, // DYNAMIC_SEQRAM_20
	{0x3D22, 0x8664}, // DYNAMIC_SEQRAM_22
	{0x3D24, 0x1030}, // DYNAMIC_SEQRAM_24
	{0x3D26, 0x801C}, // DYNAMIC_SEQRAM_26
	{0x3D28, 0x00A0}, // DYNAMIC_SEQRAM_28
	{0x3D2A, 0x56B0}, // DYNAMIC_SEQRAM_2A
	{0x3D2C, 0x5788}, // DYNAMIC_SEQRAM_2C
	{0x3D2E, 0x5150}, // DYNAMIC_SEQRAM_2E
	{0x3D30, 0x824D}, // DYNAMIC_SEQRAM_30
	{0x3D32, 0x8D58}, // DYNAMIC_SEQRAM_32
	{0x3D34, 0x58D2}, // DYNAMIC_SEQRAM_34
	{0x3D36, 0x438A}, // DYNAMIC_SEQRAM_36
	{0x3D38, 0x4592}, // DYNAMIC_SEQRAM_38
	{0x3D3A, 0x458A}, // DYNAMIC_SEQRAM_3A
	{0x3D3C, 0x4389}, // DYNAMIC_SEQRAM_3C
	{0x3D3E, 0x51FF}, // DYNAMIC_SEQRAM_3E
	{0x3D40, 0x8451}, // DYNAMIC_SEQRAM_40
	{0x3D42, 0x8410}, // DYNAMIC_SEQRAM_42
	{0x3D44, 0x0C88}, // DYNAMIC_SEQRAM_44
	{0x3D46, 0x5959}, // DYNAMIC_SEQRAM_46
	{0x3D48, 0x8A5F}, // DYNAMIC_SEQRAM_48
	{0x3D4A, 0xDA42}, // DYNAMIC_SEQRAM_4A
	{0x3D4C, 0x9361}, // DYNAMIC_SEQRAM_4C
	{0x3D4E, 0x8262}, // DYNAMIC_SEQRAM_4E
	{0x3D50, 0x8342}, // DYNAMIC_SEQRAM_50
	{0x3D52, 0x8010}, // DYNAMIC_SEQRAM_52
	{0x3D54, 0xC041}, // DYNAMIC_SEQRAM_54
	{0x3D56, 0x64FF}, // DYNAMIC_SEQRAM_56
	{0x3D58, 0xFFB7}, // DYNAMIC_SEQRAM_58
	{0x3D5A, 0x4081}, // DYNAMIC_SEQRAM_5A
	{0x3D5C, 0x4080}, // DYNAMIC_SEQRAM_5C
	{0x3D5E, 0x4180}, // DYNAMIC_SEQRAM_5E
	{0x3D60, 0x4280}, // DYNAMIC_SEQRAM_60
	{0x3D62, 0x438D}, // DYNAMIC_SEQRAM_62
	{0x3D64, 0x44BA}, // DYNAMIC_SEQRAM_64
	{0x3D66, 0x4488}, // DYNAMIC_SEQRAM_66
	{0x3D68, 0x4380}, // DYNAMIC_SEQRAM_68
	{0x3D6A, 0x4241}, // DYNAMIC_SEQRAM_6A
	{0x3D6C, 0x8140}, // DYNAMIC_SEQRAM_6C
	{0x3D6E, 0x8240}, // DYNAMIC_SEQRAM_6E
	{0x3D70, 0x8041}, // DYNAMIC_SEQRAM_70
	{0x3D72, 0x8042}, // DYNAMIC_SEQRAM_72
	{0x3D74, 0x8043}, // DYNAMIC_SEQRAM_74
	{0x3D76, 0x8D44}, // DYNAMIC_SEQRAM_76
	{0x3D78, 0xBA44}, // DYNAMIC_SEQRAM_78
	{0x3D7A, 0x875E}, // DYNAMIC_SEQRAM_7A
	{0x3D7C, 0x4354}, // DYNAMIC_SEQRAM_7C
	{0x3D7E, 0x4241}, // DYNAMIC_SEQRAM_7E
	{0x3D80, 0x8140}, // DYNAMIC_SEQRAM_80
	{0x3D82, 0x8120}, // DYNAMIC_SEQRAM_82
	{0x3D84, 0x2881}, // DYNAMIC_SEQRAM_84
	{0x3D86, 0x6026}, // DYNAMIC_SEQRAM_86
	{0x3D88, 0x8055}, // DYNAMIC_SEQRAM_88
	{0x3D8A, 0x8070}, // DYNAMIC_SEQRAM_8A
	{0x3D8C, 0x8040}, // DYNAMIC_SEQRAM_8C
	{0x3D8E, 0x4C81}, // DYNAMIC_SEQRAM_8E
	{0x3D90, 0x45C3}, // DYNAMIC_SEQRAM_90
	{0x3D92, 0x4581}, // DYNAMIC_SEQRAM_92
	{0x3D94, 0x4C40}, // DYNAMIC_SEQRAM_94
	{0x3D96, 0x8070}, // DYNAMIC_SEQRAM_96
	{0x3D98, 0x8040}, // DYNAMIC_SEQRAM_98
	{0x3D9A, 0x4C85}, // DYNAMIC_SEQRAM_9A
	{0x3D9C, 0x6CA8}, // DYNAMIC_SEQRAM_9C
	{0x3D9E, 0x6C8C}, // DYNAMIC_SEQRAM_9E
	{0x3DA0, 0x000E}, // DYNAMIC_SEQRAM_A0
	{0x3DA2, 0xBE44}, // DYNAMIC_SEQRAM_A2
	{0x3DA4, 0x8844}, // DYNAMIC_SEQRAM_A4
	{0x3DA6, 0xBC78}, // DYNAMIC_SEQRAM_A6
	{0x3DA8, 0x0900}, // DYNAMIC_SEQRAM_A8
	{0x3DAA, 0x8904}, // DYNAMIC_SEQRAM_AA
	{0x3DAC, 0x8080}, // DYNAMIC_SEQRAM_AC
	{0x3DAE, 0x0240}, // DYNAMIC_SEQRAM_AE
	{0x3DB0, 0x8609}, // DYNAMIC_SEQRAM_B0
	{0x3DB2, 0x008E}, // DYNAMIC_SEQRAM_B2
	{0x3DB4, 0x0900}, // DYNAMIC_SEQRAM_B4
	{0x3DB6, 0x8002}, // DYNAMIC_SEQRAM_B6
	{0x3DB8, 0x4080}, // DYNAMIC_SEQRAM_B8
	{0x3DBA, 0x0480}, // DYNAMIC_SEQRAM_BA
	{0x3DBC, 0x887C}, // DYNAMIC_SEQRAM_BC
	{0x3DBE, 0xAA86}, // DYNAMIC_SEQRAM_BE
	{0x3DC0, 0x0900}, // DYNAMIC_SEQRAM_C0
	{0x3DC2, 0x877A}, // DYNAMIC_SEQRAM_C2
	{0x3DC4, 0x000E}, // DYNAMIC_SEQRAM_C4
	{0x3DC6, 0xC379}, // DYNAMIC_SEQRAM_C6
	{0x3DC8, 0x4C40}, // DYNAMIC_SEQRAM_C8
	{0x3DCA, 0xBF70}, // DYNAMIC_SEQRAM_CA
	{0x3DCC, 0x5E40}, // DYNAMIC_SEQRAM_CC
	{0x3DCE, 0x114E}, // DYNAMIC_SEQRAM_CE
	{0x3DD0, 0x5D41}, // DYNAMIC_SEQRAM_D0
	{0x3DD2, 0x5383}, // DYNAMIC_SEQRAM_D2
	{0x3DD4, 0x4200}, // DYNAMIC_SEQRAM_D4
	{0x3DD6, 0xC055}, // DYNAMIC_SEQRAM_D6
	{0x3DD8, 0xA400}, // DYNAMIC_SEQRAM_D8
	{0x3DDA, 0xC083}, // DYNAMIC_SEQRAM_DA
	{0x3DDC, 0x4288}, // DYNAMIC_SEQRAM_DC
	{0x3DDE, 0x6083}, // DYNAMIC_SEQRAM_DE
	{0x3DE0, 0x5B80}, // DYNAMIC_SEQRAM_E0
	{0x3DE2, 0x5A64}, // DYNAMIC_SEQRAM_E2
	{0x3DE4, 0x1030}, // DYNAMIC_SEQRAM_E4
	{0x3DE6, 0x801C}, // DYNAMIC_SEQRAM_E6
	{0x3DE8, 0x00A5}, // DYNAMIC_SEQRAM_E8
	{0x3DEA, 0x5697}, // DYNAMIC_SEQRAM_EA
	{0x3DEC, 0x57A5}, // DYNAMIC_SEQRAM_EC
	{0x3DEE, 0x5180}, // DYNAMIC_SEQRAM_EE
	{0x3DF0, 0x505A}, // DYNAMIC_SEQRAM_F0
	{0x3DF2, 0x814D}, // DYNAMIC_SEQRAM_F2
	{0x3DF4, 0x8358}, // DYNAMIC_SEQRAM_F4
	{0x3DF6, 0x8058}, // DYNAMIC_SEQRAM_F6
	{0x3DF8, 0xA943}, // DYNAMIC_SEQRAM_F8
	{0x3DFA, 0x8345}, // DYNAMIC_SEQRAM_FA
	{0x3DFC, 0xB045}, // DYNAMIC_SEQRAM_FC
	{0x3DFE, 0x8343}, // DYNAMIC_SEQRAM_FE
	{0x3E00, 0xA351}, // DYNAMIC_SEQRAM_100
	{0x3E02, 0xE251}, // DYNAMIC_SEQRAM_102
	{0x3E04, 0x8C59}, // DYNAMIC_SEQRAM_104
	{0x3E06, 0x8059}, // DYNAMIC_SEQRAM_106
	{0x3E08, 0x8A5F}, // DYNAMIC_SEQRAM_108
	{0x3E0A, 0xEC7C}, // DYNAMIC_SEQRAM_10A
	{0x3E0C, 0xCC84}, // DYNAMIC_SEQRAM_10C
	{0x3E0E, 0x6182}, // DYNAMIC_SEQRAM_10E
	{0x3E10, 0x6283}, // DYNAMIC_SEQRAM_110
	{0x3E12, 0x4283}, // DYNAMIC_SEQRAM_112
	{0x3E14, 0x10CC}, // DYNAMIC_SEQRAM_114
	{0x3E16, 0x6496}, // DYNAMIC_SEQRAM_116
	{0x3E18, 0x4281}, // DYNAMIC_SEQRAM_118
	{0x3E1A, 0x41BB}, // DYNAMIC_SEQRAM_11A
	{0x3E1C, 0x4082}, // DYNAMIC_SEQRAM_11C
	{0x3E1E, 0x407E}, // DYNAMIC_SEQRAM_11E
	{0x3E20, 0xCC41}, // DYNAMIC_SEQRAM_120
	{0x3E22, 0x8042}, // DYNAMIC_SEQRAM_122
	{0x3E24, 0x8043}, // DYNAMIC_SEQRAM_124
	{0x3E26, 0x8300}, // DYNAMIC_SEQRAM_126
	{0x3E28, 0xC088}, // DYNAMIC_SEQRAM_128
	{0x3E2A, 0x44BA}, // DYNAMIC_SEQRAM_12A
	{0x3E2C, 0x4488}, // DYNAMIC_SEQRAM_12C
	{0x3E2E, 0x00C8}, // DYNAMIC_SEQRAM_12E
	{0x3E30, 0x8042}, // DYNAMIC_SEQRAM_130
	{0x3E32, 0x4181}, // DYNAMIC_SEQRAM_132
	{0x3E34, 0x4082}, // DYNAMIC_SEQRAM_134
	{0x3E36, 0x4080}, // DYNAMIC_SEQRAM_136
	{0x3E38, 0x4180}, // DYNAMIC_SEQRAM_138
	{0x3E3A, 0x4280}, // DYNAMIC_SEQRAM_13A
	{0x3E3C, 0x4383}, // DYNAMIC_SEQRAM_13C
	{0x3E3E, 0x00C0}, // DYNAMIC_SEQRAM_13E
	{0x3E40, 0x8844}, // DYNAMIC_SEQRAM_140
	{0x3E42, 0xBA44}, // DYNAMIC_SEQRAM_142
	{0x3E44, 0x8800}, // DYNAMIC_SEQRAM_144
	{0x3E46, 0xC880}, // DYNAMIC_SEQRAM_146
	{0x3E48, 0x4241}, // DYNAMIC_SEQRAM_148
	{0x3E4A, 0x8240}, // DYNAMIC_SEQRAM_14A
	{0x3E4C, 0x8140}, // DYNAMIC_SEQRAM_14C
	{0x3E4E, 0x8041}, // DYNAMIC_SEQRAM_14E
	{0x3E50, 0x8042}, // DYNAMIC_SEQRAM_150
	{0x3E52, 0x8043}, // DYNAMIC_SEQRAM_152
	{0x3E54, 0x8300}, // DYNAMIC_SEQRAM_154
	{0x3E56, 0xC088}, // DYNAMIC_SEQRAM_156
	{0x3E58, 0x44BA}, // DYNAMIC_SEQRAM_158
	{0x3E5A, 0x4488}, // DYNAMIC_SEQRAM_15A
	{0x3E5C, 0x00C8}, // DYNAMIC_SEQRAM_15C
	{0x3E5E, 0x8042}, // DYNAMIC_SEQRAM_15E
	{0x3E60, 0x4181}, // DYNAMIC_SEQRAM_160
	{0x3E62, 0x4082}, // DYNAMIC_SEQRAM_162
	{0x3E64, 0x4080}, // DYNAMIC_SEQRAM_164
	{0x3E66, 0x4180}, // DYNAMIC_SEQRAM_166
	{0x3E68, 0x4280}, // DYNAMIC_SEQRAM_168
	{0x3E6A, 0x4383}, // DYNAMIC_SEQRAM_16A
	{0x3E6C, 0x00C0}, // DYNAMIC_SEQRAM_16C
	{0x3E6E, 0x8844}, // DYNAMIC_SEQRAM_16E
	{0x3E70, 0xBA44}, // DYNAMIC_SEQRAM_170
	{0x3E72, 0x8800}, // DYNAMIC_SEQRAM_172
	{0x3E74, 0xC880}, // DYNAMIC_SEQRAM_174
	{0x3E76, 0x4241}, // DYNAMIC_SEQRAM_176
	{0x3E78, 0x8140}, // DYNAMIC_SEQRAM_178
	{0x3E7A, 0x9F5E}, // DYNAMIC_SEQRAM_17A
	{0x3E7C, 0x8A54}, // DYNAMIC_SEQRAM_17C
	{0x3E7E, 0x8620}, // DYNAMIC_SEQRAM_17E
	{0x3E80, 0x2881}, // DYNAMIC_SEQRAM_180
	{0x3E82, 0x6026}, // DYNAMIC_SEQRAM_182
	{0x3E84, 0x8055}, // DYNAMIC_SEQRAM_184
	{0x3E86, 0x8070}, // DYNAMIC_SEQRAM_186
	{0x3E88, 0x0000}, // DYNAMIC_SEQRAM_188
	{0x3E8A, 0x0000}, // DYNAMIC_SEQRAM_18A
	{0x3E8C, 0x0000}, // DYNAMIC_SEQRAM_18C
	{0x3E8E, 0x0000}, // DYNAMIC_SEQRAM_18E
	{0x3E90, 0x0000}, // DYNAMIC_SEQRAM_190
	{0x3E92, 0x0000}, // DYNAMIC_SEQRAM_192
	{0x3E94, 0x0000}, // DYNAMIC_SEQRAM_194
	{0x3E96, 0x0000}, // DYNAMIC_SEQRAM_196
	{0x3E98, 0x0000}, // DYNAMIC_SEQRAM_198
	{0x3E9A, 0x0000}, // DYNAMIC_SEQRAM_19A
	{0x3E9C, 0x0000}, // DYNAMIC_SEQRAM_19C
	{0x3E9E, 0x0000}, // DYNAMIC_SEQRAM_19E
	{0x3EA0, 0x0000}, // DYNAMIC_SEQRAM_1A0
	{0x3EA2, 0x0000}, // DYNAMIC_SEQRAM_1A2
	{0x3EA4, 0x0000}, // DYNAMIC_SEQRAM_1A4
	{0x3EA6, 0x0000}, // DYNAMIC_SEQRAM_1A6
	{0x3EA8, 0x0000}, // DYNAMIC_SEQRAM_1A8
	{0x3EAA, 0x0000}, // DYNAMIC_SEQRAM_1AA
	{0x3EAC, 0x0000}, // DYNAMIC_SEQRAM_1AC
	{0x3EAE, 0x0000}, // DYNAMIC_SEQRAM_1AE
	{0x3EB0, 0x0000}, // DYNAMIC_SEQRAM_1B0
	{0x3EB2, 0x0000}, // DYNAMIC_SEQRAM_1B2
	{0x3EB4, 0x0000}, // DYNAMIC_SEQRAM_1B4
	{0x3EB6, 0x004D}, // DAC_LD_0_1
	{0x3EBC, 0xAA06}, // DAC_LD_6_7
	{0x3EC0, 0x2E02}, // DAC_LD_10_11
	{0x3EC2, 0x7700}, // DAC_LD_12_13
	{0x3EC4, 0x1C08}, // DAC_LD_14_15
	{0x3EC6, 0xEA44}, // DAC_LD_16_17
	{0x3EC8, 0x0F0F}, // DAC_LD_18_19
	{0x3ECA, 0x0F4A}, // DAC_LD_20_21
	{0x3ECC, 0x0706}, // DAC_LD_22_23
	{0x3ECE, 0x443B}, // DAC_LD_24_25
	{0x3ED0, 0x12F0}, // DAC_LD_26_27
	{0x3ED2, 0x0039}, // DAC_LD_28_29
	{0x3ED4, 0x862F}, // DAC_LD_30_31
	{0x3ED6, 0x4080}, // DAC_LD_32_33
	{0x3ED8, 0x0523}, // DAC_LD_34_35
	{0x3EDA, 0xF8AA}, // DAC_LD_36_37
	{0x3EDC, 0x5078}, // DAC_LD_38_39
	{0x3EDE, 0x5005}, // DAC_LD_40_41
	{0x316A, 0x8200}, // DAC_RSTLO
	{0x316E, 0x8200}, // DAC_ECL
	{0x316C, 0x8200}, // DAC_TXLO
	{0x3EF0, 0x414D}, // DAC_LD_ECL
	{0x3EF2, 0x0101}, // DAC_LD_FSC
	{0x3EF6, 0x0307}, // DAC_LD_RSTD
	{0x3EFA, 0x0F0F}, // DAC_LD_TXLO
	{0x3EFC, 0x0F0F}, // DAC_LD_TXLO1
	{0x3EFE, 0x0F0F}, // DAC_LD_TXLO2
	{0x31B0, 0x004D}, // FRAME_PREAMBLE
	{0x31B2, 0x0028}, // LINE_PREAMBLE
	{0x31B4, 0x230E}, // MIPI_TIMING_0
	{0x31B6, 0x1348}, // MIPI_TIMING_1
	{0x31B8, 0x1C12}, // MIPI_TIMING_2
	{0x31BA, 0x185B}, // MIPI_TIMING_3
	{0x31BC, 0x8509}, // MIPI_TIMING_4
	{0x0300, 0x0004}, // VT_PIX_CLK_DIV
	{0x0302, 0x0001}, // VT_SYS_CLK_DIV
	{0x0304, 0x0A0A}, // PRE_PLL_CLK_DIV
	{0x0306, 0xB7B7}, // PLL_MULTIPLIER	MCLK,48M
	{0x0308, 0x000A}, // OP_PIX_CLK_DIV
	{0x030A, 0x0001}, // OP_SYS_CLK_DIV
	{0x0112, 0x0A0A}, // CCP_DATA_FORMAT
	{0x3016, 0x0101}, // ROW_SPEED
	{0x0344, 0x00C8}, // X_ADDR_START
	{0x0348, 0x0FC7}, // X_ADDR_END
	{0x0346, 0x01F0}, // Y_ADDR_START
	{0x034A, 0x0A5D}, // Y_ADDR_END
	{0x034C, 0x0780}, // X_OUTPUT_SIZE
	{0x034E, 0x0438}, // Y_OUTPUT_SIZE
	{0x3040, 0x0043}, // READ_MODE
	{0x3172, 0x0206}, // ANALOG_CONTROL2
	{0x317A, 0x516E}, // ANALOG_CONTROL6
	{0x3F3C, 0x0003}, // ANALOG_CONTROL9
	{0x0400, 0x0001}, // SCALING_MODE
	{0x0404, 0x0020}, // SCALE_M
	{0x0342, 0x1230}, // LINE_LENGTH_PCK
	{0x0340, 0x0C4E}, // FRAME_LENGTH_LINES
	{0x0202, 0x0C4E}, // COARSE_INTEGRATION_TIME
	{0x30FE, 0x0060}, // CTREE_OFF
	{0x31E0, 0x0781}, // PIX_DEF_ID
	{0x3F00, 0x004F}, // BM_T0
	{0x3F02, 0x0125}, // BM_T1
	{0x3F04, 0x0020}, // NOISE_GAIN_THRESHOLD0
	{0x3F06, 0x0040}, // NOISE_GAIN_THRESHOLD1
	{0x3F08, 0x0070}, // NOISE_GAIN_THRESHOLD2
	{0x3F0A, 0x0101}, // NOISE_FLOOR10
	{0x3F0C, 0x0302}, // NOISE_FLOOR32
	{0x3F1E, 0x0022}, // NOISE_COEF
	{0x3F1A, 0x01FF}, // CROSSFACTOR2
	{0x3F14, 0x0101}, // SINGLE_K_FACTOR2
	{0x3F44, 0x0707}, // COUPLE_K_FACTOR2
	{0x3F18, 0x011E}, // CROSSFACTOR1
	{0x3F12, 0x0303}, // SINGLE_K_FACTOR1
	{0x3F42, 0x1511}, // COUPLE_K_FACTOR1
	{0x3F16, 0x011E}, // CROSSFACTOR0
	{0x3F10, 0x0505}, // SINGLE_K_FACTOR0
	{0x3F40, 0x1511}, // COUPLE_K_FACTOR0
	{0x3F3C, 0x0003}, // ANALOG_CONTROL9
	{0x301A, 0x021C}, // RESET_REGISTER
};

#define AR1335_PIXEL_FORMAT  MEDIA_BUS_FMT_SGRBG10_1X10
static const struct ar1335_mode ar1335_modes[] = {
	/* 3840x2160 10-bit mode. Full resolution centre-cropped. */
	{
		.format = {
			.code		= AR1335_PIXEL_FORMAT,
			.colorspace	= V4L2_COLORSPACE_SRGB,
			.field		= V4L2_FIELD_NONE,
			.width		= 3840,
			.height		= 2160
		},
		.pixel_rate	= 281600000,
		.hts		= 0x1230,
		.vts		= 0x0BCC,
		.reg_list	= ar1335_3840x2160_20fps_raw10_48Mxclk,
		.num_regs	= ARRAY_SIZE(ar1335_3840x2160_20fps_raw10_48Mxclk)
	},
	/* 2048x1536 10-bit mode. Full resolution centre-cropped. */
	{
		.format = {
			.code		= AR1335_PIXEL_FORMAT,
			.colorspace	= V4L2_COLORSPACE_SRGB,
			.field		= V4L2_FIELD_NONE,
			.width		= 2048,
			.height		= 1536
		},
		.pixel_rate	= 439200000,
		.hts		= 0x1230,
		.vts		= 0x0C4E,
		.reg_list	= ar1335_2048x1536_30fps_raw10_48Mxclk,
		.num_regs	= ARRAY_SIZE(ar1335_2048x1536_30fps_raw10_48Mxclk)
	},
	/* 1920x1080 10-bit mode. Full resolution centre-cropped. */
	{
		.format = {
			.code		= AR1335_PIXEL_FORMAT,
			.colorspace	= V4L2_COLORSPACE_SRGB,
			.field		= V4L2_FIELD_NONE,
			.width		= 1920,
			.height		= 1080
		},
		.pixel_rate	= 439200000,
		.hts		= 0x1230,
		.vts		= 0x0C4E,
		.reg_list	= ar1335_1920x1080_30fps_raw10_48Mxclk,
		.num_regs	= ARRAY_SIZE(ar1335_1920x1080_30fps_raw10_48Mxclk)
	},
};

/* Default sensor mode is 2x2 binned 640x480 SBGGR10_1X10. */
#define AR1335_DEFAULT_MODE	(&ar1335_modes[1])
#define AR1335_DEFAULT_FORMAT	(ar1335_modes[1].format)

static int ar1335_write16(struct v4l2_subdev *sd, u16 reg, u16 val)
{
	unsigned char data[4] = { reg >> 8, reg & 0xff, val >> 8, val & 0xff};
	struct i2c_client *client = v4l2_get_subdevdata(sd);
	int ret;

	ret = i2c_master_send(client, data, 4);
	if (ret < 0) {
		dev_dbg(&client->dev, "%s: i2c write error, reg: %x",
			__func__, reg);
		return ret;
	}

	return 0;
}

static int ar1335_write(struct v4l2_subdev *sd, u16 reg, u8 val)
{
	unsigned char data[3] = { reg >> 8, reg & 0xff, val};
	struct i2c_client *client = v4l2_get_subdevdata(sd);
	int ret;

	ret = i2c_master_send(client, data, 3);
	if (ret < 0) {
		dev_err(&client->dev, "%s: i2c write error, reg: %x",
				__func__, reg);
		return ret;
	}

	return 0;
}

static int ar1335_read(struct v4l2_subdev *sd, u16 reg, u8 *val)
{
	unsigned char data_w[2] = { reg >> 8, reg & 0xff };
	struct i2c_client *client = v4l2_get_subdevdata(sd);
	int ret;

	ret = i2c_master_send(client, data_w, 2);
	if (ret < 0) {
		dev_err(&client->dev, "%s: i2c write error, reg: %x",
			__func__, reg);
		return ret;
	}

	ret = i2c_master_recv(client, val, 1);
	if (ret < 0) {
		dev_err(&client->dev, "%s: i2c read error, reg: %x",
				__func__, reg);
		return ret;
	}

	return 0;
}

static int ar1335_write_array(struct v4l2_subdev *sd,
				  const struct regval_list *regs, int array_size)
{
	int i, ret;

	for (i = 0; i < array_size; i++) {
		if (regs[i].addr == REG_DELAY) {
			msleep(regs[i].data);
			continue;
		}
		ret = ar1335_write16(sd, regs[i].addr, regs[i].data);
		if (ret < 0) {
			dev_err(sd->dev, "write sensor regs[%i] addr = 0x%04X, data = 0x%04X, error %d",
					i, regs[i].addr, regs[i].data, ret);
			return ret;
		}
	}

	return 0;
}

static int ar1335_set_mode(struct v4l2_subdev *sd)
{
	struct ar1335 *sensor = to_sensor(sd);
	int ret;
	//dev_info(sd->dev, ">>> %s:%d <<<", __func__, __LINE__);

	ret = ar1335_write_array(sd, sensor->mode->reg_list,
				 sensor->mode->num_regs);
	if (ret < 0) {
		return ret;
	}

	return 0;
}

static int ar1335_stream_on(struct v4l2_subdev *sd)
{
	struct i2c_client *client = v4l2_get_subdevdata(sd);
	int ret;
	//dev_info(sd->dev, ">>> %s:%d <<<", __func__, __LINE__);

	ret = ar1335_set_mode(sd);
	if (ret) {
		dev_err(&client->dev, "Failed to program sensor mode: %d", ret);
		return ret;
	}

	/* Apply customized values from user when stream starts. */
	ret =  __v4l2_ctrl_handler_setup(sd->ctrl_handler);
	if (ret)
		return ret;

	return 0;
}

static int ar1335_stream_off(struct v4l2_subdev *sd)
{
	int ret;
	//dev_info(sd->dev, ">>> %s:%d <<<", __func__, __LINE__);

	ret = ar1335_write(sd, AR1335_REG_SW_RESET, 0x01);
	if (ret < 0)
		return ret;

	msleep(10);
	return 0;
}

static int ar1335_power_on(struct device *dev)
{
	struct ar1335 *sensor = dev_get_drvdata(dev);
	int ret;

	dev_info(dev, "AR1335 power on");

	if (sensor->pwdn) {
		gpiod_set_value_cansleep(sensor->pwdn, 0);
		msleep(PWDN_ACTIVE_DELAY_MS);
	}

	ret = clk_prepare_enable(sensor->xclk);
	if (ret < 0) {
		dev_err(dev, "clk prepare enable failed");
		goto error_pwdn;
	}

	return 0;

error_pwdn:
	gpiod_set_value_cansleep(sensor->pwdn, 1);

	return ret;
}

static int ar1335_power_off(struct device *dev)
{
	struct ar1335 *sensor = dev_get_drvdata(dev);

	dev_info(dev, "AR1335 power off");

	clk_disable_unprepare(sensor->xclk);
	gpiod_set_value_cansleep(sensor->pwdn, 1);

	return 0;
}

/* Subdev core operations registration */
static const struct v4l2_subdev_core_ops ar1335_subdev_core_ops = {
	.subscribe_event	= v4l2_ctrl_subdev_subscribe_event,
	.unsubscribe_event	= v4l2_event_subdev_unsubscribe,
};

static int ar1335_s_stream(struct v4l2_subdev *sd, int enable)
{
	struct i2c_client *client = v4l2_get_subdevdata(sd);
	struct ar1335 *sensor = to_sensor(sd);
	int ret;
	dev_info(sd->dev, ">>> %s:%d enable %d <<<", __func__, __LINE__, enable);

	mutex_lock(&sensor->lock);
	if (sensor->streaming == enable) {
		mutex_unlock(&sensor->lock);
		return 0;
	}

	if (enable) {
		ret = pm_runtime_resume_and_get(&client->dev);
		if (ret < 0)
			goto error_unlock;

		ret = ar1335_stream_on(sd);
		if (ret < 0) {
			dev_err(&client->dev, "stream start failed: %d", ret);
			goto error_pm;
		}
	} else {
		ret = ar1335_stream_off(sd);
		if (ret < 0) {
			dev_err(&client->dev, "stream stop failed: %d", ret);
			goto error_pm;
		}
		pm_runtime_put(&client->dev);
	}

	sensor->streaming = enable;
	mutex_unlock(&sensor->lock);

	return 0;

error_pm:
	pm_runtime_put(&client->dev);
error_unlock:
	mutex_unlock(&sensor->lock);

	return ret;
}

static const struct v4l2_subdev_video_ops ar1335_subdev_video_ops = {
	.s_stream =		ar1335_s_stream,
};

static int ar1335_enum_mbus_code(struct v4l2_subdev *sd,
				 struct v4l2_subdev_state *sd_state,
				 struct v4l2_subdev_mbus_code_enum *code)
{
	//dev_info(sd->dev, ">>> %s:%d <<<", __func__, __LINE__);
	if (code->index > 0)
		return -EINVAL;

	code->code = AR1335_PIXEL_FORMAT;

	return 0;
}

static int ar1335_enum_frame_size(struct v4l2_subdev *sd,
				  struct v4l2_subdev_state *sd_state,
				  struct v4l2_subdev_frame_size_enum *fse)
{
	const struct v4l2_mbus_framefmt *fmt;
	//dev_info(sd->dev, ">>> %s:%d <<<", __func__, __LINE__);

	if (fse->code != AR1335_PIXEL_FORMAT ||
		fse->index >= ARRAY_SIZE(ar1335_modes))
		return -EINVAL;

	fmt = &ar1335_modes[fse->index].format;
	fse->min_width = fmt->width;
	fse->max_width = fmt->width;
	fse->min_height = fmt->height;
	fse->max_height = fmt->height;

	return 0;
}

static int ar1335_get_pad_fmt(struct v4l2_subdev *sd,
				  struct v4l2_subdev_state *sd_state,
				  struct v4l2_subdev_format *format)
{
	struct v4l2_mbus_framefmt *fmt = &format->format;
	const struct v4l2_mbus_framefmt *sensor_format;
	struct ar1335 *sensor = to_sensor(sd);
	//dev_info(sd->dev, ">>> %s:%d <<<", __func__, __LINE__);

	mutex_lock(&sensor->lock);
	switch (format->which) {
	case V4L2_SUBDEV_FORMAT_TRY:
		sensor_format = v4l2_subdev_get_try_format(sd, sd_state,
							   format->pad);
		break;
	default:
		sensor_format = &sensor->mode->format;
		break;
	}

	*fmt = *sensor_format;
	mutex_unlock(&sensor->lock);

	return 0;
}

static int ar1335_set_pad_fmt(struct v4l2_subdev *sd,
				  struct v4l2_subdev_state *sd_state,
				  struct v4l2_subdev_format *format)
{
	struct v4l2_mbus_framefmt *fmt = &format->format;
	struct ar1335 *sensor = to_sensor(sd);
	const struct ar1335_mode *mode;
	//dev_info(sd->dev, ">>> %s:%d <<<", __func__, __LINE__);

	mode = v4l2_find_nearest_size(ar1335_modes, ARRAY_SIZE(ar1335_modes),
					  format.width, format.height,
					  fmt->width, fmt->height);

	/* Update the sensor mode and apply at it at streamon time. */
	mutex_lock(&sensor->lock);
	if (format->which == V4L2_SUBDEV_FORMAT_TRY) {
		*v4l2_subdev_get_try_format(sd, sd_state, format->pad) = mode->format;
	} else {
		int exposure_max, exposure_def;
		int hblank, vblank;

		sensor->mode = mode;
		__v4l2_ctrl_modify_range(sensor->pixel_rate, mode->pixel_rate,
					 mode->pixel_rate, 1, mode->pixel_rate);

		hblank = mode->hts - mode->format.width;
		__v4l2_ctrl_modify_range(sensor->hblank, hblank, hblank, 1,
					 hblank);

		vblank = mode->vts - mode->format.height;
		__v4l2_ctrl_modify_range(sensor->vblank, AR1335_VBLANK_MIN,
					 AR1335_VTS_MAX - mode->format.height,
					 1, vblank);
		__v4l2_ctrl_s_ctrl(sensor->vblank, vblank);

		exposure_max = mode->vts - 1;
		exposure_def = min(exposure_max, AR1335_EXPOSURE_DEFAULT);
		__v4l2_ctrl_modify_range(sensor->exposure,
					 sensor->exposure->minimum,
					 exposure_max, sensor->exposure->step,
					 exposure_def);
	}
	*fmt = mode->format;
	mutex_unlock(&sensor->lock);

	return 0;
}

static const struct v4l2_subdev_pad_ops ar1335_subdev_pad_ops = {
	.enum_mbus_code		= ar1335_enum_mbus_code,
	.enum_frame_size	= ar1335_enum_frame_size,
	.set_fmt		= ar1335_set_pad_fmt,
	.get_fmt		= ar1335_get_pad_fmt,
};

static const struct v4l2_subdev_ops ar1335_subdev_ops = {
	.core		= &ar1335_subdev_core_ops,
	.video		= &ar1335_subdev_video_ops,
	.pad		= &ar1335_subdev_pad_ops,
};

static int ar1335_detect(struct v4l2_subdev *sd)
{
	struct i2c_client *client = v4l2_get_subdevdata(sd);
	u8 read;
	int ret;

	ret = ar1335_write(sd, AR1335_REG_SW_RESET, 0x01);
	if (ret < 0) {
		return ret;
	}

	msleep(10);

	ret = ar1335_read(sd, AR1335_REG_CHIPID_H, &read);
	if (ret < 0) {
		return ret;
	}

	if (read != 0x01) {
		dev_err(&client->dev, "ID High expected 0x01 got %x", read);
		return -ENODEV;
	}

	ret = ar1335_read(sd, AR1335_REG_CHIPID_L, &read);
	if (ret < 0) {
		return ret;
	}

	if (read != 0x53) {
		dev_err(&client->dev, "ID Low expected 0x47 got %x", read);
		return -ENODEV;
	}

	dev_info(&client->dev, "Aptina AR1335 (ID:0x0153) detected!");
	return 0;
}

static int ar1335_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
{
	struct v4l2_mbus_framefmt *format =
				v4l2_subdev_get_try_format(sd, fh->state, 0);
	//dev_info(sd->dev, ">>> %s:%d <<<", __func__, __LINE__);
	*format = AR1335_DEFAULT_FORMAT;

	return 0;
}

static int ar1335_close(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
{
	//dev_info(sd->dev, ">>> %s:%d <<<", __func__, __LINE__);
	return 0;
}

static const struct v4l2_subdev_internal_ops ar1335_subdev_internal_ops = {
	.open = ar1335_open,
	.close = ar1335_close,
};

static int ar1335_s_ctrl(struct v4l2_ctrl *ctrl)
{
	struct ar1335 *sensor = container_of(ctrl->handler,
						struct ar1335, ctrls);
	struct v4l2_subdev *sd = &sensor->sd;
	struct i2c_client *client = v4l2_get_subdevdata(sd);
	int ret = 0;

	//dev_info(sd->dev, ">>> %s:%d <<<", __func__, __LINE__);

	/* v4l2_ctrl_lock() locks our own mutex */

	if (ctrl->id == V4L2_CID_VBLANK) {
		int exposure_max, exposure_def;

		/* Update max exposure while meeting expected vblanking */
		exposure_max = sensor->mode->format.height + ctrl->val - 1;
		exposure_def = min(exposure_max, AR1335_EXPOSURE_DEFAULT);
		__v4l2_ctrl_modify_range(sensor->exposure,
					 sensor->exposure->minimum,
					 exposure_max, sensor->exposure->step,
					 exposure_def);
	}

	/*
	 * If the device is not powered up do not apply any controls
	 * to H/W at this time. Instead the controls will be restored
	 * at s_stream(1) time.
	 */
	if (pm_runtime_get_if_in_use(&client->dev) == 0)
		return 0;

	switch (ctrl->id) {
	case V4L2_CID_ANALOGUE_GAIN:
		ret = ar1335_write16(sd, AR1335_REG_GAIN, ctrl->val);
		break;
	case V4L2_CID_EXPOSURE:
		ret = ar1335_write16(sd, AR1335_REG_EXPOSURE, ctrl->val);
		break;
	case V4L2_CID_VBLANK:
		ret = ar1335_write16(sd, AR1335_REG_VTS, sensor->mode->format.height + ctrl->val);
		break;

	/* Read-only, but we adjust it based on mode. */
	case V4L2_CID_PIXEL_RATE:
	case V4L2_CID_HBLANK:
		/* Read-only, but we adjust it based on mode. */
		break;

	default:
		dev_err(&client->dev,
			 "Control (id:0x%x, val:0x%x) not supported",
			 ctrl->id, ctrl->val);
		ret = -EINVAL;
	}

	pm_runtime_put(&client->dev);

	return ret;
}

static const struct v4l2_ctrl_ops ar1335_ctrl_ops = {
	.s_ctrl = ar1335_s_ctrl,
};

static int ar1335_init_controls(struct ar1335 *sensor)
{
	struct i2c_client *client = v4l2_get_subdevdata(&sensor->sd);
	int hblank, exposure_max, exposure_def;

	v4l2_ctrl_handler_init(&sensor->ctrls, 8);

	exposure_max = sensor->mode->vts - 1;
	exposure_def = min(exposure_max, AR1335_EXPOSURE_DEFAULT);
	sensor->exposure = v4l2_ctrl_new_std(&sensor->ctrls, &ar1335_ctrl_ops,
						 V4L2_CID_EXPOSURE,
						 AR1335_EXPOSURE_MIN,
						 exposure_max, AR1335_EXPOSURE_STEP,
						 exposure_def);

	/* min: 16 = 1.0x; max (10 bits); default: 32 = 2.0x. */
	v4l2_ctrl_new_std(&sensor->ctrls, &ar1335_ctrl_ops,
			  V4L2_CID_ANALOGUE_GAIN, 0x2010, 0x633f, 1, 0x2010); //FIXME

	/* By default, PIXEL_RATE is read only, but it does change per mode */
	sensor->pixel_rate = v4l2_ctrl_new_std(&sensor->ctrls, &ar1335_ctrl_ops,
						   V4L2_CID_PIXEL_RATE,
						   sensor->mode->pixel_rate,
						   sensor->mode->pixel_rate, 1,
						   sensor->mode->pixel_rate);

	/* By default, HBLANK is read only, but it does change per mode. */
	hblank = sensor->mode->hts - sensor->mode->format.width;
	sensor->hblank = v4l2_ctrl_new_std(&sensor->ctrls, &ar1335_ctrl_ops,
					   V4L2_CID_HBLANK, hblank, hblank, 1,
					   hblank);

	sensor->vblank = v4l2_ctrl_new_std(&sensor->ctrls, &ar1335_ctrl_ops,
					   V4L2_CID_VBLANK, AR1335_VBLANK_MIN,
					   AR1335_VTS_MAX -
					   sensor->mode->format.height, 1,
					   sensor->mode->vts -
					   sensor->mode->format.height);

	if (sensor->ctrls.error)
		goto handler_free;

	sensor->pixel_rate->flags |= V4L2_CTRL_FLAG_READ_ONLY;
	sensor->hblank->flags |= V4L2_CTRL_FLAG_READ_ONLY;
	sensor->sd.ctrl_handler = &sensor->ctrls;

	return 0;

handler_free:
	dev_err(&client->dev, "%s Controls initialization failed (%d)",
		__func__, sensor->ctrls.error);
	v4l2_ctrl_handler_free(&sensor->ctrls);

	return sensor->ctrls.error;
}

static int ar1335_probe(struct i2c_client *client)
{
	struct device *dev = &client->dev;
	struct ar1335 *sensor;
	struct v4l2_subdev *sd;
	u32 xclk_freq;
	int ret;

	sensor = devm_kzalloc(dev, sizeof(*sensor), GFP_KERNEL);
	if (!sensor) {
		dev_err(dev, "malloc for sensor context fail");
		return -ENOMEM;
	}

	sensor->xclk = devm_clk_get(dev, NULL);
	if (IS_ERR(sensor->xclk)) {
		dev_err(dev, "could not get xclk");
		return PTR_ERR(sensor->xclk);
	}

	xclk_freq = clk_get_rate(sensor->xclk);
	if (xclk_freq != 48000000) {
		dev_err(dev, "Unsupported clock frequency: %u", xclk_freq);
		return -EINVAL;
	}

	/* Request the power down GPIO asserted. */
	sensor->pwdn = devm_gpiod_get_optional(dev, "pwdn", GPIOD_OUT_HIGH);
	if (IS_ERR(sensor->pwdn)) {
		dev_err(dev, "Failed to get 'pwdn' gpio");
		return -EINVAL;
	}

	mutex_init(&sensor->lock);

	sensor->mode = AR1335_DEFAULT_MODE;

	ret = ar1335_init_controls(sensor);
	if (ret) {
		goto mutex_destroy;
	}

	sd = &sensor->sd;
	v4l2_i2c_subdev_init(sd, client, &ar1335_subdev_ops);
	sd->internal_ops = &ar1335_subdev_internal_ops;
	sd->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE | V4L2_SUBDEV_FL_HAS_EVENTS;

	sensor->pad.flags = MEDIA_PAD_FL_SOURCE;
	sd->entity.function = MEDIA_ENT_F_CAM_SENSOR;
	ret = media_entity_pads_init(&sd->entity, 1, &sensor->pad);
	if (ret < 0) {
		dev_err(dev, "media entity pads init fail");
		goto ctrl_handler_free;
	}

	ret = ar1335_power_on(dev);
	if (ret) {
		goto entity_cleanup;
	}

	ret = ar1335_detect(sd);
	if (ret < 0) {
		goto power_off;
	}

	ret = v4l2_async_register_subdev(sd);
	if (ret < 0) {
		dev_err(dev, "v4l2 async register subdev fail");
		goto power_off;
	}

	/* Enable runtime PM and turn off the device */
	pm_runtime_set_active(dev);
	pm_runtime_enable(dev);
	pm_runtime_idle(dev);

	dev_info(dev, "Aptina AR1335 camera driver probed!");

	return 0;

power_off:
	ar1335_power_off(dev);
entity_cleanup:
	media_entity_cleanup(&sd->entity);
ctrl_handler_free:
	v4l2_ctrl_handler_free(&sensor->ctrls);
mutex_destroy:
	mutex_destroy(&sensor->lock);

	return ret;
}

static int ar1335_remove(struct i2c_client *client)
{
	struct v4l2_subdev *sd = i2c_get_clientdata(client);
	struct ar1335 *sensor = to_sensor(sd);

	v4l2_async_unregister_subdev(&sensor->sd);
	media_entity_cleanup(&sensor->sd.entity);
	v4l2_ctrl_handler_free(&sensor->ctrls);
	v4l2_device_unregister_subdev(sd);
	pm_runtime_disable(&client->dev);
	mutex_destroy(&sensor->lock);

	return 0;
}

static const struct dev_pm_ops ar1335_pm_ops = {
	SET_RUNTIME_PM_OPS(ar1335_power_off, ar1335_power_on, NULL)
};

static const struct i2c_device_id ar1335_id[] = {
	{ "ar1335", 0 },
	{ /* sentinel */ }
};
MODULE_DEVICE_TABLE(i2c, ar1335_id);

// ar1335: camera@36 {
// 	compatible = "aptina,ar1335";
// 	reg = <0x36>;
// 	clocks = <&misc_clk_1>;
// 	clock-names = "xclk";
// 	pwdn-gpios = <&axi_gpio 2 1>;
// 	port {
// 		ar1335_csi2_out: endpoint {
// 			remote-endpoint = <&mipi_csi_inmipi_csi2_rx_ias1>;
// 			clock-lanes = <0>;
// 			data-lanes = <1 2 3 4>;
// 		};
// 	};
// };

#if IS_ENABLED(CONFIG_OF)
static const struct of_device_id ar1335_of_match[] = {
	{ .compatible = "aptina,ar1335" },
	{ /* sentinel */ },
};
MODULE_DEVICE_TABLE(of, ar1335_of_match);
#endif

static struct i2c_driver ar1335_driver = {
	.driver = {
		.of_match_table = of_match_ptr(ar1335_of_match),
		.name	= "ar1335",
		.pm	= &ar1335_pm_ops,
	},
	.probe_new	= ar1335_probe,
	.remove		= ar1335_remove,
	.id_table	= ar1335_id,
};

module_i2c_driver(ar1335_driver);

MODULE_AUTHOR("xinquan.bian<544177215@qq.com>");
MODULE_DESCRIPTION("A low-level driver for Aptina ar1335 sensors");
MODULE_LICENSE("GPL v2");
